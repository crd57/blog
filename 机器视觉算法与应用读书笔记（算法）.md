# 机器视觉算法与应用读书笔记（算法）
## 1.数据结构
## 2.图像增强
### 1. 灰度值变换
### 2. 辐射标定
### 3. 图像平滑
#### 1. 时域去噪法
#### 2. 空间域去噪法
1. 均值滤波器
递归线性滤波器：将上次计算得到的值带入到下次的值中
缺点：噪声并不能被全部消除
2. 高斯滤波器
[高斯滤波器][1]
### 4. 傅里叶变换
将函数h(x)从空间域转变到频率域
是一种可逆变换
##3. 几何变换
### 1. 仿射变换
二维to二维之间的变换
 对图像中的物体的尺寸进行修正（平移和旋转角度修正）
一般有一个2x2的线性部分和一个平移部分
###2. 投影变换
高维to二维之间的变换
仿射变换（特殊的投影变换）
需要八个参数（4个点）
###3. 图像变换
####1. 最临近插值：
转化后坐标的x位于四个像素点中心店之间，是一个非整数的的位置，对非整数位置取整，以找到与此坐标相邻的四个像素点的中心位置中最近的一个，然后将输入图像里的这个最邻近点位置的像素的灰度值视为输出图像内相应像素点的灰度值。
容易导致锯齿状外观
####2. 双线性插值：
首先，分别计算转换后的坐标到四个相邻近像素中心点的垂直方向和水平方向的距离根据距离值（0-1之间）计算不同灰度值所占的权重后得到双线性插值的结果。
###4. 极坐标变换：
通常被用来 矫正图像中的圆形物体或被包含在圆环中物体。
## <font color=red>4. 图像分割</font>:
### 1. 阈值分割
一个好的阈值对应着  <font color=red>直方图中两个峰之间的最小值。</font>
But 灰度直方图的随机波动，所以需要鲁棒的方法选定的话，必须对直方图进行平滑处理即将直方图与一个一维高斯滤波器进行卷积来完成平滑处理。为了给高斯滤波器选定合适的	值，一个好的策略是逐渐增大	并平滑直方图，直到可以从平滑后的直方图中得到唯一的最大值和他们之间的一个唯一的最小值。
####<font color=red> 动态阈值分割 </font>:
使用均值、高斯或中值滤波器，进行平滑处理就可以计算出以当前像素为中心的窗口内的平均灰度值（背景值）。
将图像与局部背景进行的比较被称为动态阈值分割
对亮物体的动态阈值分割处理：
图像值-背景值
对暗物体的阈值分割：
背景值-图像值
平滑滤波器的尺寸决定了能被分割出来的物体的尺寸。（滤波器的大小应该大于被提取物体的大小）
<font color=red> 动态阈值分割 可以用来检测异常</font>:
  待测物体值-图像物体值>某一阈值
*前提*：待测物的图像和参考图像必须精确对准，
####异常检测：偏差模型法
	用n幅训练影像的平均值用来模型化参考图像，用n幅训练影像的标准差来模型化参考图像允许的偏差。（当偏差太小时不适用，此时应添加一个绝对的阈值）
### 2. 提取连通区域
#### 如何定义像素连通：
1. 两个像素有共同的边缘
2. 将对角线也包括进来
前后景必须使用不同的连通定义
在用行程表示法描述的区域上计算连通区域，可以使用深度优先搜索
### 3. 亚像素精度阈值分割
提取到的不可能是面，应该是亚像素精度的轮廓，表示图像中两个区域之间的边界。
表示这两个边界，必须将图像的离散表示转换为一个连续的函数
## 5. 特征提取
### 1.区域特征
####1. 基于矩的特征
面积是被称为区域的矩的广义特征中的一个特例。
$$m_{p,q} = \sum_{(r,c)\in r} r^pc^q$$
$m_{0,0}$就是区域的面积
当$p+q\ge1$时。矩除以面积得到归一化的矩
归一化的矩是由图像的位置决定的。通常，使特征不随图像中区域的位置变化而变化是很有用的。这些中心矩是在$(p+q\ge2)$时由下式实现的：
$$\mu_{p,q}=\frac{1}{a}\sum(r-n_{1,0})^p(c-n_{0,1})^q$$
二阶中心距$(p+q=2)$尤其值得关注，它可以用来定义区域的方位和区域的范围。
####2. 基于外接几何基元（矩形，圆）
可以计算宽度、高度、宽高比
计算任一方位的外接圆的方法是基于首先计算区域的凸包
基于此区域的凸包，能够定义另一个有用的特性：凸性
凸性被定义为某区域的面积和该区域凸包的面积的比值，用来测量区域的紧凑程度
区域的轮廓长度
###2.灰度值特征
在一个参考区域测出的平均值和标准差也能被用来建立一个线性灰度值变换，此变换可以补偿亮度的变化。
##6.形态学
###1.区域形态学
所有的区域形态学处理能根据六个非常简单的操作来定义：并集，交集，差集，补集，平移和转置。
[膨胀、腐蚀、开操作、闭操作][2]
膨胀和腐蚀也被称为最大值滤波和最小值滤波
形态学梯度算子：
膨胀-腐蚀
###2.灰度值形态学
##7.边缘提取
### 1. 在一维和二维中的边缘定义
1. 一维
$$|f^{\prime}|\gg 0$$
通常有很多彼此相连的点都满足此条件，因为背景灰度值到前景灰度值过度是光滑的。因此为了获得唯一的边缘位置，我们必须加入额外的要求，即一维导数的绝对值$|f'(x)|$是局部最大值。这就是**非最大抑制**
$$f^{\prime\prime}=0$$
$$f^{\prime}f^{\prime\prime\prime} < 0$$
$$f^{\prime}>0是正边缘$$
$$f^{\prime}<0是负边缘$$

2. 二维
$$\bigtriangledown f = \bigtriangledown f(r,c) = (\frac{\vartheta{f(r,c)}}{\vartheta{r}},\frac{\vartheta{f(r,c)}}{\vartheta{c}})=(f_r ,f_c)$$
$$||\triangledown||_2=\sqrt{f_r^2+f_c^2}$$
等价于一维中的一阶导数的绝对值$|f^{\prime}(x)|$
梯度方向：
$$\phi=-arctan(f_r/f_c)$$
注意$\phi$沿从横轴开始的算数正方向（逆时针方向）增大
拉普拉斯算子：
$$\triangle f = \triangle f(r,c) = (\frac{\vartheta^2{f(r,c)}}{\vartheta{r^2}},\frac{\vartheta^2{f(r,c)}}{\vartheta{c^2}})=(f_{rr} ,f_{cc})$$
边缘能通过拉普拉斯算子过零计算得到：
$$\triangle f(r,c)=0$$
只有在笔直的边缘是局部梯度最大和拉普拉斯算子返回一值，梯度量值局部最大来定义的边缘总落在联想拐角内，拉普拉斯算子过零来定义的边缘总落在理想拐角外
### 2. 一维边缘提取
速度快常被用来确定一个物体的位置和尺寸
#### 第一个问题：如何计算离散一维灰度值剖面的导数？
一阶倒数
$$f'_{i}=\frac{1}{2}(f_{i+1}-f_{i-1})$$
二阶导数
$$f'’_{i}=\frac{1}{2}(f_{i+1}-2f_i+f_{i-1})$$
即以下的卷积掩码：
$$\frac{1}{2}[1,0,-1]和\frac{1}{2}[1,-2,1]$$
计算斜线、圆或椭圆上的剖面时，生成若干条垂直于我们获取灰度值破面的那条线。而线上的点通常不落在像素的中心上，此时需要进行插值处理。
因为噪声容易导致过多的二阶倒数为零，所以使用二阶导数不容易提取出明显的边缘。
为了抑制噪声，可以在灰度值剖面的那条直线的垂线方向上对多个灰度值进行适当的的平均，但是当被检测物体具有非常多的纹理，或者无法选取足够多的像素进行平均时，无法被抑制。
此时我们对灰度值剖面进行平滑处理，这样我们在剖面上提取边缘时需要两个卷积，此时可将这两个卷积合成一个卷积——边缘滤波器
***canny准则（怎么样算好的边缘探测器）：***
1. 对一个边缘点的错检和漏检的可能性都要低
2. 提取出来的边缘尽可能的靠紧真正的边缘
3. 对每个真正的边缘都只返回唯一的边缘（提取出来的边缘位置之间的距离最大化）
canny认为最好的边缘滤波器是高斯滤波器的一阶导数。
Deriche 提出了改进了Canny的算法提出了能以递归方式实现的两个滤波器：
$$d'_{\alpha}(x) = -{\alpha}^2xe^{-\alpha|x|}$$
$$e'_\alpha(x)=-2\alpha sin(\alpha x)e^{-\alpha|x|}$$
对应的平滑滤波器：
$$d_\alpha (x)=\frac{1}{4}\alpha(\alpha|x|+1)e^{-\alpha|x|}$$
$$e_\alpha(x)=\frac{1}{2}\alpha[sin(\alpha|x|)+cos(\alpha|x|)]e^{-\alpha|x|}$$
*亚像元边缘提取*
用边缘幅度最大值周围的三个点来拟合抛物线，然后计算此抛物线的最大值
###3.二维边缘提取
$$
f{r;i,j}=\frac{1}{2}(f{i+1,j}-f_{i-1,j})
$$

$$f_{c;i,j}=\frac{1}{2}(f_{i+1,j}-f_{i-1,j})$$
$$\left[
  \begin{matrix}
   1 & 0 & -1 \\
   a & 0 & -a \\
   1 & 0 & -1
  \end{matrix}\right]\tag{1}
$$
注意在卷积时滤波器掩码被镜像：
$$\left[
  \begin{matrix}
    1 & a & 1 \\
    0 & 0 & 0 \\
   -1 & a & -1
  \end{matrix}\right]\tag{1}
$$
当$a=1时$，我们得到$Prewitt$滤波器，垂直与到导数方向上滤波
当$a=\sqrt{2}$时，我们得到了$Frei$滤波器
当$a=2时$，我们得到了$Sobel$滤波器，垂直与导数的方向上近似于高斯平滑滤波。
当$a=2.435101$时，我们得到了$Ando$滤波
因为2-范数耗时太大，所以经常用
1-范数（4连通）：
$$||\triangledown{f}||_1 = |f_r|+|f_c|$$
或者最大范数（8连通）：
$$||\triangledown{f}||_{\infty}=\max(|f_r|,|f_c|)$$
由于$3×3$鲁棒性不好
所以使用Canny二维形式：
$$g_r=\sqrt{2\pi}{\sigma}g'_{\sigma}(r)g_{\sigma}(c)$$
和
$$g_c=\sqrt{2\pi}{\sigma}g'_{\sigma}(c)g_{\sigma}(r)$$
[边缘检测之Canny算子][3]
[非极大值抑制][4]
##8. 几何基元的分割与拟合
###1.直线拟合
直线的表示方法：黑塞范式
$${\alpha}r+{\beta}c+{\gamma}=0$$
$${\alpha}^2+{\beta}^2=1$$
拟合直线即使点到直线的距离最小化：
$${\varepsilon}^2 = \sum_{i=1}^n({\alpha}r_i+{\beta}c_i+{\gamma})^2-\lambda({\alpha}^2+{\beta}^2-1)n$$
以此方法得到的$(\alpha,\beta)$,它既是直线的法向量，也是从点集的椭圆参数得到的短轴
为了降低远离点的影响可以加入权重。
那么最小化的过程就变成了：
$${\varepsilon}^2 ={\omega}_i \sum_{i=1}^n({\alpha}r_i+{\beta}c_i+{\gamma})^2-\lambda({\alpha}^2+{\beta}^2-1)n$$
确定权重的方法：多次迭代法。
*权重函数：*
Huber法：
$$\omega(\sigma)=(x)=\left\{
\begin{aligned}
1 && |\sigma|\leqslant r \\
r/|\sigma|&& |\sigma|> r
\end{aligned}
\right.$$
Tukey法：
$$\omega(\sigma)=(x)=\left\{
\begin{aligned}
\lbrack1-(\sigma/r)^2\rbrack^2 && |\sigma|\leqslant r \\
0&& |\sigma|> r
\end{aligned}
\right.$$
其中$r$是削波函数，手动设置，一般为$r=2{\sigma}_\delta$
$${\sigma}_\delta=\frac{media|\sigma_i|}{0.6745}$$
$RANSAC算法$
相继丢弃离群值，通过随机选择的最少数量的点来构造一个解。
###2. 圆拟合
$${\varepsilon}^2 = \sum_{i=1}^n(\sqrt{(r_i-\alpha)^2(c_i-\beta)^2}-\rho$$
也可以加入权重，和使用$RANSAC算法$
###3. 椭圆拟合
椭圆的隐式方程：
$${\alpha}r^2+{\beta}rc+{\gamma}c^2+{\delta}r+{\zeta}c
+\eta=0$$
$${\beta}^2-4{\alpha}{\gamma}=-1$$
###4.将轮廓分割为直线、圆和椭圆
直线拟合：
Rammer算法对轮廓进行递归细分，直到得到的全部线段到各自对应的轮廓段的最大距离小于用户设置的阈值
实际应用：
先以亚像素准确度提取边缘，然后用Rammer算法以多边形对提取后的边缘进行逼近。
将轮廓分割为直线和圆的算法分为两类：
1.将那些与明确实体相对应的轮廓上的断点识别出来
2、一开始将轮廓分割成直线，第二步检查过度分割线段能否被合并成圆或者椭圆。
##9.摄像机标定
##10.立体重构
##11.模板匹配
[模板匹配][5]
应用场合：
    1.完整性检测2.物体识别3.确定目标物体的位姿
###1. 基于灰度值的模板匹配
###2.使用图形金字塔进行匹配
###3.基于灰度值的亚像素精度匹配
###4.带旋转与缩放的模板匹配
对搜索空间离散化：创建多个方向的模板
更大的模板使用更小的步幅，更小的模板使用更大的步幅
###5.可靠地模板匹配算法
图像的边缘很少收光线变化的影响，但是边缘提取时存在如何选择合适的阈值的问题，这就是为什么需要匹配算法足够可靠地能够处理遮挡和混乱的情况。
边缘匹配策略：
1、我们可以在匹配中使用原始的边缘点，或者增加每个点的一些特性。
2、将边缘分割为多个几何基元，然后在图像中匹配这些分割得到的几何基元
3、基于边缘的分割，我们可以得到边缘的突变点然后匹配这些突变点。
边缘匹配算法的类别：
1、基于模板边缘与图像边缘的距离
2、基于相似度量
几何哈希法



  

  

  



[1]: https://www.cnblogs.com/wangguchangqing/p/6407717.html
[2]: https://blog.csdn.net/Fishmemory/article/details/53113746?locationNum=6&amp;fps=1
[3]: https://www.cnblogs.com/techyan1990/p/7291771.html
[4]: https://blog.csdn.net/kezunhai/article/details/11620357
[5]: https://blog.csdn.net/lz0499/article/details/69364871